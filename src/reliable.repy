def reliable_recvmess(srcip, srcport, function):
  print "Server starts receiving from", srcport
  expected_seqnumber = 0
  def onreceive(remoteip, remoteport, message, commhandle):
    print "Server receives:", message
    actual_seqnumber = int(message[0])
    if actual_seqnumber == expected_seqnumber:
      print "Server sends ACK", actual_seqnumber, "to", remoteport
      stopcomm(commhandle)
      sendmess(remoteip, remoteport, str(actual_seqnumber), srcip, srcport)
      function(remoteip, remoteport, message, commhandle)
  return recvmess(srcip, srcport, onreceive)

def chunks(message, chunk_length):
  indexes = range(0, len(message), chunk_length)
  return [ message[i:i+chunk_length] for i in indexes ]

def reliable_sendmess(destip, destport, message, srcip=None, srcport=None):
  dgramsize = mycontext["maxdgramsize"]
  payloads = chunks(message, dgramsize)
  
  print "Client starts sending from", srcport, "to", destport
  
  seqnumber = 0
  retries = mycontext["retries"]
  for payload in payloads:
    reliable_try_send_packet(destip, destport, payload, seqnumber, retries, srcip, srcport)
    seqnumber = 1 - seqnumber

def reliable_try_send_packet(destip, destport, payload, seqnumber, retries, srcip=None, srcport=None):
  wrapped_message = str(seqnumber) + ',' + payload
  mycontext['retries_left'] = retries
  mycontext['timer'] = None
  mycontext['sent'] = False
  mycontext['bytes'] = 0
  # float() is important or we will get integer division.
  timeout_seconds = float(mycontext["timeoutinms"]) / 1000
  
  def send():
    print "Client sends packet,", mycontext['retries_left'], "retries left"
    mycontext['timer'] = settimer(timeout_seconds, ack_timeout, [])
    mycontext['bytes'] = sendmess(destip, destport, wrapped_message, srcip, srcport)
  
  def ack_timeout():
    print "Client did not receive ACK"
    if mycontext['retries_left'] > 0:
      mycontext['retries_left'] = mycontext['retries_left'] - 1
      send()
    else:
      mycontext['sent'] = False # Not necessary, but makes it clear what happens here.
      lock.release()
  
  def ack_received(remoteip, remoteport, ack_message, commhandle):
    # We have received a packet from the client, but the ACK number is not 
    # relevant, because we're only waiting for a single ACK at any given time.
    print "Client receives ACK"
    mycontext['sent'] = True # Ensure that we return correctly at the end of this function.
    
    canceltimer(mycontext['timer']) # Stop retrying.
    lock.release()
  
  lock = getlock()
  lock.acquire()
  
  send()
  
  print "Client waits to receive ACK to", srcport
  commhandle = recvmess(srcip, srcport, ack_received)
  
  lock.acquire()
  
  # Wait for the lock to be released after a set number of timeouts of after an ACK is received.
  
  stopcomm(commhandle)
	
  if mycontext['sent']:
    return bytes
  else:
    raise Exception("Client fails sending after", mycontext['retries'], "retries")

mycontext["delim"] = ","
mycontext["maxdgramsize"] = 512
mycontext["retries"] = 3 
mycontext["timeoutinms"] = 1000
def reliable_config(maxdgramsize, retries, timeoutinms):
  mycontext["maxdgramsize"] = maxdgramsize
  mycontext["retries"] = retries
  mycontext["timeoutinms"] = timeoutinms

def get_payload(message):
  header_length = 1 + len(mycontext["delim"])
  return message[header_length:]